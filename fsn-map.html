<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../google-map/google-map.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../paper-progress/paper-progress.html">

<dom-module id="fsn-map">
  <template>
    <style>
      :host {
        display: block;
      }
      paper-progress {
        display: block;
        width: 100%;

      }
      paper-fab {
        position: absolute;
        bottom: 10px;
        right: 10px;
      }
    </style>

    <iron-ajax
          auto
          id="ajax"
          url="https://vatsim-status-proxy.herokuapp.com/clients"
          handle-as="json"
          last-response="{{clients}}"
          on-response="handleResponse"
          loading="{{_ajaxLoading}}"></iron-ajax>

    <iron-ajax
          auto
          id="firs"
          url="https://v4p4sz5ijk.execute-api.us-east-1.amazonaws.com/anbdata/airspaces/zones/fir-list"
          params='{"api_key":"2a877ab0-4ed2-11e7-9b2e-d3182793b831", "firs": "", "format": "json"}'
          handle-as="json"
          last-response="{{firs}}"
          on-response="handleFirs"
          debounce-duration="3000"></iron-ajax>

    <paper-progress indeterminate id="progress"></paper-progress>
    <google-map
          additional-map-options='{"mapTypeId":"satellite"}'
          disable-default-ui
          fit-to-marker
          api-key="AIzaSyDj4y39JAORYGw4rNcA1y8oVj0m8lNDje4"
          latitude="40.0955474"
          longitude="-3.070306"
          zoom="4"
          drag-events="true"
          id="map"></google-map>

  </template>

  <script>
    /**
     * `fsn-map`
     * Dynamic flight sim traffic map
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class FsnMap extends Polymer.Element {
      static get is() { return 'fsn-map'; }

      static get observers() {
        return [
            '_ajaxLoadingChanged(_ajaxLoading)'
        ]
      }
      static get properties() {
        return {
          /**
          * Viewport center position at time of last data provider call
          */
          _lastRequestedCenter: {
            type: Object
          },
          /**
          * Viewport size at time of last data provider call
          */
          _lastRequestedViewportDistance: {
            type: Number
          },
          _ajaxLoading: {
            type: Boolean,
            notify: true,
            value: false
          },
          lastLatitude: {
            type: Number,
            value: 0
          },
          lastLongitude: {
            type: Number,
            value: 0
          },
          lastZoom: {
            type: Number,
            value: 0
          },
          aircraftMarkers: {
            type: Array,
            value: {}
          },
          selectedPilot: {
            type: String,
            value: ''
          },
          updating: {
            type: Boolean,
            value: false
          }
        }
      }
      ready() {
        super.ready();
        this.$.map.addEventListener('google-map-drag', e => {this._mapViewportUpdate(e)});
        this.$.map.addEventListener('zoom-changed', e => {this._mapViewportUpdate(e)});
      }
      _ajaxLoadingChanged(loading) {
        if (loading) {
          this.$.progress.indeterminate = true;
        } else {
          this.$.progress.indeterminate = false;
        }
      }

      handleFirs() {
        var firs = this.firs;

        // parse FIRs
        for (var i = 0, len = firs.length; i < len; i++) {
          var fir = firs[i];
          
          // parse geometries
          var _coordinates = undefined;
          var geometry = fir.geometry;
          if (geometry.type == "Polygon") {
            var _coordinates = geometry.coordinates[0];            
          } else if (geometry.type == "MultiPolygon") {
            var _coordinates = geometry.coordinates[0][1];
          }
          if (_coordinates != undefined) {
            var coordinates = this._getFirCoordinates(_coordinates);
            var firGeometry = new google.maps.Polyline({
              path: coordinates,
              geodesic: true,
              strokeColor: "#FFF",
              strokeOpacity: 0.4,
              strokeWeight: 0.7
            });
            firGeometry.setMap(this.$.map.map);
          }
        }
      }
      _getFirCoordinates(_coordinates) {
        var coordinates = [];   
        for (var coordinatesIndex = 0, len = _coordinates.length; coordinatesIndex < len; coordinatesIndex++) {
          coordinates.push({lat: _coordinates[coordinatesIndex][1], lng: _coordinates[coordinatesIndex][0]});
        }
        return coordinates;
      }
      handleResponse() {
        var clients = this.clients._items;
        for (var i = 0, len = clients.length; i < len; i++) {
          var client = clients[i];
          if (client.clienttype == 'PILOT') {
            var client_x_sprite = client.heading;
            if (client_x_sprite > 180) {
              client_x_sprite = client_x_sprite - 180;
            } else {
              client_x_sprite = client_x_sprite + 180;
            }
            client_x_sprite = Math.round(Math.abs(client_x_sprite / 15));
            var image = {
              url: 'https://rawgit.com/pedro2555/pedro-toolbox/master/images/aircraft-icons.png',
              // This marker is 20 pixels wide by 32 pixels high.
              size: new google.maps.Size(23, 23),
              // The origin for this image is (0, 0).
              origin: new google.maps.Point(client_x_sprite * 48, 3 * 48),
              // The anchor for this image is the base of the flagpole at (0, 32).
              anchor: new google.maps.Point(24, 24)
            };
            var shape = {
              coords: [1, 1, 1, 20, 18, 20, 18, 1],
              type: 'poly'
            };
            var marker = this.aircraftMarkers[client.callsign + client.cid];
            if (marker != undefined) {
              marker.setPosition({lat: client['location'][1], lng: client['location'][0]});
              marker.setIcon(image);
            } else {
              // Add the new marker
              marker = new google.maps.Marker({
                position: {lat: client['location'][1], lng: client['location'][0]},
                map: this.$.map.map,
                label: client.route,
                icon: image,
                title: client.callsign
              });
              // marker.addListener('click', function (e) {
              //   this.selectedPilot = marker.title;
              //   console.log(this.selectedPilot);
              // });
              this.aircraftMarkers[client.callsign + client.cid] = marker;
            }
          }
        }
      }
      _mapDragRequiresUpdate() {
        // check if viewport has new area to update
        // you can do that by simply computing the distance from the current center
        //  and the distance between the center point used for the last data request,
        //  if that distance is bigger than viewport total distance we should force a
        //  data request

        // if map is not ready, no reason to pull data
        if (!this.$.map.map) {
          return false
        }

        // if no last update, grab some data
        if (!this._lastRequestedCenter) {
          this._lastRequestedCenter = this.$.map.map.getCenter();
          return true
        }

        // otherwise compute map viewport geometric deslocation to update new visible areas
        // get distance from southwest to northeast corner
        var southwest = this.$.map.map.getBounds().getSouthWest();
        var northeast = this.$.map.map.getBounds().getNorthEast();

        // get view port distance
        var distance = southwest && northeast ? google.maps.geometry.spherical.computeDistanceBetween(southwest, northeast) : 10000;
        if (google.maps.geometry.spherical.computeDistanceBetween(this._lastRequestedCenter, this.$.map.map.getCenter()) > distance / 2) {
          this._lastRequestedCenter = this.$.map.map.getCenter();
          return true
        }

        return false
      }
      _mapViewportUpdate(e, force=false) {
        if (this._mapDragRequiresUpdate() || force) {
          this.$.ajax.params = this.computeParams();
          this.$.ajax.generateRequest();
        }
      }
      _computeWhere() {
        // center point
        var center = this.$.map.map.getBounds().getCenter();

        // get distance from southwest to northeast corner
        var southwest = this.$.map.map.getBounds().getSouthWest();
        var northeast = this.$.map.map.getBounds().getNorthEast();

        // get view port distance
        var distance = southwest && northeast ? google.maps.geometry.spherical.computeDistanceBetween(southwest, northeast) : 10000;

        // TODO: Parse the MongoDB query below appropriately
        //console.log('{"location": {"$near":{ "$geometry": {"type": "Point", "coordinates": [' + center.lng() + ', ' + center.lat() + ']}, "$maxDistance": ' + Math.floor(distance) + '}}}');
        return '{"location": {"$near":{ "$geometry": {"type": "Point", "coordinates": [' + center.lng() + ', ' + center.lat() + ']}, "$maxDistance": ' + Math.floor(distance) + '}}}'
      }
      computeParams() {
        return {where: this._computeWhere()}
      }
    }

    window.customElements.define(FsnMap.is, FsnMap);
  </script>
</dom-module>
